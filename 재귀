중급 개발자를 대상으로 **재귀(Recursion)**에 대한 개념과 활용법을 정리한 특강 자료입니다. 재귀 함수의 정의와 동작 원리부터 반복문과의 비교, 재귀 함수를 효율적으로 설계하는 방법, 백트래킹에서의 활용, 그리고 사용 시 주의사항과 코딩 테스트 예제까지 폭넓게 다룹니다. 코드 예제와 함께 설명하여 이해를 돕고, 실무나 코딩 테스트에 바로 적용할 수 있도록 구성했습니다.
1. 재귀 개념
재귀란 자기 자신을 정의하거나 호출하는 개념을 말합니다. 컴퓨터 프로그래밍에서 재귀 호출(recursive call)은 함수가 실행 중에 자기 자신을 다시 호출하는 함수 호출 방식입니다​
CATSBI.OOPY.IO
. 즉, 재귀 함수는 자기 자신을 호출함으로써 반복 작업을 수행하는 함수입니다. 이러한 함수는 적어도 하나의 **기본 단계(base case)**를 가져야 하며, 이 단계에서 재귀 호출 없이 직접 결과를 반환합니다. 그리고 자기 자신을 호출하는 **재귀 단계(recursive case)**가 존재하여 문제를 더 작은 버전으로 쪼개어 해결합니다. 재귀 호출은 문제를 작게 나누어 해결하는 분할 정복 기법이나 수학적 귀납 원리와 그 맥락을 같이합니다.재귀 함수가 호출될 때마다 **콜 스택(call stack)**에 함수의 **스택 프레임(stack frame)**이 쌓입니다. 각 호출된 함수는 자신의 지역 변수, 매개변수, 반환 주소 등을 스택에 쌓아 두고 일시 중단된 채로 다음 재귀 호출로 넘어갑니다​
CATSBI.OOPY.IO
. 재귀 호출이 계속되다가 기본 단계에 도달하면, 더 이상 재귀 호출을 하지 않고 값을 반환합니다. 이후 스택 언와인딩(unwinding) 과정에서 마지막 호출된 함수부터 차례로 복귀하며 각 자기 호출에게 반환값을 전달해 최종 결과를 얻습니다. 이러한 동작 방식은 함수가 자기 자신을 호출할 때마다 새로운 컨텍스트가 생성되고, 결과를 반환하며 컨텍스트가 소멸되는 흐름으로 이해할 수 있습니다.

위 그림은 재귀 함수 factorial(5) 호출 시 콜 스택의 변화를 단계별로 나타낸 것입니다. 함수 호출이 중첩될 때마다 새 스택 프레임(지역 변수, 반환 주소 값, 매개변수)이 쌓이고, 기본 단계에 도달한 후에는 스택이 거꾸로 풀리며 값이 반환됩니다.기본적인 예제: 아래는 재귀 함수의 가장 전형적인 예제로 자주 언급되는 팩토리얼 계산 함수입니다. 팩토리얼 $n!$은 수학적으로 $n \times (n-1) \times \dots \times 1$로 정의되며, 재귀적으로도 정의할 수 있습니다 (1! = 1, n! = n * (n-1)! for n > 1).
python
복사
편집
def factorial(n):
    # 기본 단계: n이 1 또는 0이면 팩토리얼 결과는 1
    if n <= 1:
        return 1
    # 재귀 단계: n * factorial(n-1)을 계산
    return n * factorial(n-1)

print(factorial(5))  # 출력: 120
위 factorial 함수는 n이 1 이하가 될 때까지 자기 자신을 호출하며, 가장 깊은 호출에서 1을 반환한 뒤 차례로 곱셈을 수행하면서 반환합니다. 예를 들어 factorial(5)를 호출하면 내부적으로 5 * 4 * 3 * 2 * 1의 계산 과정으로 이어지며 최종 결과로 120을 반환합니다. 이때 재귀 호출의 흐름은 factorial(5) → factorial(4) → ... → factorial(1)까지 내려갔다가, 반환하면서 곱셈을 수행해 올라오는 순서로 진행됩니다. 이처럼 재귀 함수를 이해할 때는 재귀 호출의 내려가기 과정과 결과가 돌아오는 과정을 구분해서 생각해야 합니다.
2. 재귀가 필요한 이유 (반복문과의 비교)
프로그래밍에서 반복적인 로직을 구현하는 방법에는 **재귀 함수(recursion)**와 **반복문(iteration)**이 있습니다. 일반적으로 대부분의 반복 작업은 반복문으로 구현 가능하며, 재귀로 표현된 로직은 반복문으로도 변환할 수 있고 그 역도 성립합니다​
CATSBI.OOPY.IO
. 그럼에도 불구하고 재귀를 사용하는 이유는 문제의 성질이나 가독성 측면에서 재귀가 더 적합하거나 편리한 경우가 있기 때문입니다. 재귀의 장단점을 반복문과 비교하여 살펴보면 다음과 같습니다:
재귀 사용의 장점: 재귀를 사용하면 코드가 구조적으로 간결해지고 이해하기 쉬워지는 경우가 많습니다. 반복문을 사용하면 loop 내부에서 여러 단계의 처리를 작성해야 하지만, 재귀는 문제를 쪼개는 논리에 집중하여 코드 길이를 줄일 수 있습니다​
MELONICEDLATTE.COM
. 또한 함수 호출마다 상태를 스택에 저장하므로, 추가적인 상태를 추적하기 위한 전역 변수나 복잡한 자료 구조 없이도 상태 보존이 가능합니다​
MELONICEDLATTE.COM
. 예를 들어, 복잡한 트리(tree) 구조를 순회하거나, 백트래킹과 같이 분기마다 상태를 저장/복구해야 하는 문제에서 재귀를 쓰면 명시적으로 스택을 관리하지 않아도 되어 구현이 깔끔합니다.
재귀 사용의 단점: 재귀 함수는 반복문에 비해 성능 오버헤드가 있을 수 있습니다. 함수가 호출될 때마다 호출을 위한 추가 작업(스택에 컨텍스트 쌓기 등)이 발생하여 함수 호출/복귀의 부가 비용이 듭니다​
CATSBI.OOPY.IO
​
MELONICEDLATTE.COM
. 또한 각 재귀 호출마다 메모리(stack 영역)를 사용하므로, 동일한 작업을 반복문으로 수행할 때보다 메모리 사용량이 증가하고 성능이 떨어질 수 있습니다​
CATSBI.OOPY.IO
​
MELONICEDLATTE.COM
. 특히 재귀 호출이 너무 깊어지면 스택 오버플로우(stack overflow) 에러가 발생할 위험도 있습니다. (파이썬의 경우 기본 재귀 한도는 약 1000회로 설정되어 있습니다​
PYTHONCENTRAL.IO
.) 그에 반해 반복문은 한 함수 내에서 변수 값만 바꾸며 실행되므로 호출 overhead가 없고 일반적으로 더 빠르고 메모리 효율적입니다.
요약하면, 재귀는 코드 구현을 직관적이고 간결하게 만들어주지만 잘못 사용하면 성능 저하나 스택 오버플로우를 초래할 수 있습니다. 반복문은 저수준에서 효율적이지만 복잡한 문제를 표현할 때 코드가 장황해질 수 있습니다. 따라서 문제의 특성과 우선순위에 따라 재귀와 반복을 선택하게 됩니다. 예를 들어 피보나치 수열을 단순 재귀로 계산하면 동일 계산의 반복으로 비효율적이지만, 트리 순회나 그래프 탐색(DFS)은 재귀를 쓰면 매우 간결하게 구현됩니다. 중요한 것은 재귀를 사용할 때 문제를 올바르게 **재귀적 사고(recursive thinking)**로 모델링하고, 필요하면 반복 구조로 대체하는 유연함을 가지는 것입니다.
3. 재귀 설계 및 구현 (기법과 최적화)
효율적인 재귀 함수를 설계하려면 몇 가지 원칙을 염두에 두어야 합니다. 재귀 설계의 핵심은 두 부분: ① **기본 단계(base case)**를 명확히 정의하고, ② **재귀 단계(recursive step)**에서 문제를 어떻게 더 작은 문제로 분할할지 정하는 것입니다. 이때 각 재귀 호출이 기본 단계에 점진적으로 다가가도록 설계해야 무한 루프에 빠지지 않습니다. 재귀를 설계하는 구체적인 방법과 최적화 기법을 살펴보겠습니다.
기본 단계와 재귀 단계 설정: 재귀 함수를 작성할 때 가장 먼저 해야 할 일은 *"언제 재귀 호출을 멈출 것인가?"*를 정하는 것입니다​
JTODAY.TISTORY.COM
​
JTODAY.TISTORY.COM
. 보통 입력값이 가장 단순해졌을 때 (예: 리스트가 빈 경우, 숫자가 0 또는 1인 경우 등) 바로 해결하는 분기를 기본 단계로 만듭니다. 그리고 기본 단계가 아닌 경우 문제를 더 작은 문제로 줄여서 자기 자신을 호출합니다. 예를 들어, 팩토리얼 함수에서 n <= 1일 때 바로 1을 반환하는 부분이 기본 단계이고, 그렇지 않은 경우 n * factorial(n-1)로 문제를 축소하는 부분이 재귀 단계입니다. 또 다른 예로 배열 합계를 구하는 재귀 함수를 생각해보면, 배열이 빈 경우 0을 반환하는 것이 기본 단계, 그렇지 않으면 첫 요소 + 재귀호출(나머지 배열 합계)이 재귀 단계가 될 것입니다. 이렇게 문제를 작게 쪼개고 남은 부분을 자기 자신에게 위임함으로써 재귀 해결이 가능합니다.
재귀적 사고(Inductive thinking): 재귀를 설계할 때는 수학적 귀납법과 비슷하게 *"작은 문제는 제대로 해결된다고 가정하고, 그것을 이용해 큰 문제를 해결한다"*는 사고방식이 중요합니다​
JUN-N.TISTORY.COM
. 예를 들어 n개의 원소를 가진 문제를 해결하려면, 우선 (n-1)개 원소의 문제는 해결되었다고 가정하고 그 결과를 이용해 n개 문제를 해결하는 식으로 생각해 보는 것입니다. 이러한 접근은 재귀 함수의 correctness를 이해하는 데에도 도움이 됩니다. 작은 입력에 대한 해결 방법을 알면, 재귀 호출이 그것을 잘 이용하도록 함으로써 큰 입력도 해결할 수 있다는 논리입니다. 이처럼 재귀 함수를 만들 때는 1) 기본 단계의 해답은 옳다는 것과 2) 재귀 단계에서 자기 자신을 믿고 사용하는 것이 핵심입니다. 자기 자신을 호출할 때는 더 작은 문제가 올바르게 풀린다고 가정하고, 그 결과를 조합해 현재 문제를 풀도록 로직을 구성해야 합니다.
메모이제이션(Memoization): 재귀 호출의 중복 계산 문제를 해결하는 대표적인 최적화 기법이 메모이제이션입니다. 메모이제이션이란 한 번 계산한 결과를 저장하여 동일한 입력으로 함수를 다시 호출하면 저장된 결과를 바로 반환함으로써 불필요한 계산을 제거하는 방법입니다​
VELOG.IO
. 동적 계획법(DP)의 탑다운(top-down) 방식에서 흔히 활용되며, 재귀+캐싱으로 이해할 수 있습니다. 예를 들어, 피보나치 수열을 재귀로 계산할 때 단순 구현은 지수적으로 많은 중복 호출을 발생시키지만, 메모이제이션을 적용하면 각 수를 한 번만 계산하게 만들어 효율을 크게 높일 수 있습니다. 아래는 파이썬으로 구현한 피보나치 수열 예시입니다.
python
복사
편집
# 피보나치 수 재귀 (메모이제이션 없이)
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

# 피보나치 수 재귀 (메모이제이션 적용)
memo = {}
def fib_memo(n):
    if n <= 1:
        return n
    if n in memo:            # 이미 계산된 값이면 바로 반환
        return memo[n]
    memo[n] = fib_memo(n-1) + fib_memo(n-2)  # 계산 결과 저장
    return memo[n]

print(fib(6))       # 출력: 8  (여러 번의 중복 계산 발생)
print(fib_memo(6))  # 출력: 8  (중복 계산 없이 빠르게 결과 얻음)
위 코드에서 fib 함수는 같은 값들을 반복해서 재귀 호출로 계산하므로 비효율적이지만, fib_memo 함수는 딕셔너리 memo를 활용하여 이미 구한 값을 저장해두고 재사용하기 때문에 불필요한 계산을 하지 않습니다. 메모이제이션은 이처럼 중복되는 부분 문제의 재사용을 통해 재귀 알고리즘의 시간 복잡도를 획기적으로 개선하는 기법이며, 피보나치 외에도 다양한 재귀 문제(여러 DP 문제)에 적용됩니다.
꼬리 재귀(Tail Recursion): 꼬리 재귀는 재귀 최적화 기법 중 하나로, 함수의 마지막 동작으로 자기 자신을 호출하는 형태를 말합니다. 즉, 재귀 호출 뒤에 별도의 연산을 하지 않고 바로 반환만 하는 형태의 재귀입니다​
CATSBI.OOPY.IO
​
MELONICEDLATTE.COM
. 이 경우 컴파일러나 인터프리터가 최적화를 지원하면, 재귀 호출을 반복문처럼 변환하여 호출 스택을 증가시키지 않고 실행할 수 있습니다. 예를 들어 앞서 제시한 팩토리얼 함수를 꼬리 재귀 형태로 바꿔보겠습니다:
python
복사
편집
def factorial_tail(n, acc=1):
    if n <= 1:
        return acc
    return factorial_tail(n-1, acc * n)
위 factorial_tail 함수는 acc 누산기(accumulator)에 계산 결과를 누적하면서 재귀 호출합니다. 재귀 호출 이외에 추가 연산을 하지 않기 때문에 이론상 스택 프레임을 재사용할 수 있는 형태입니다. 중요: 파이썬은 자동으로 꼬리 재귀 최적화를 하지 않지만, Java나 Scala 같은 일부 언어에서는 컴파일러가 꼬리 재귀를 감지하여 반복문으로 변경해주므로 스택 오버플로우를 방지하고 성능을 개선할 수 있습니다​
CATSBI.OOPY.IO
. 꼬리 재귀로 작성할 수 있는 경우라면 이러한 최적화를 알고 활용하는 것이 좋습니다. 하지만 꼬리 재귀가 아닌 일반 재귀는 호출이 깊어지면 언어별 한계 내에서 스택 사용량이 누적된다는 점을 기억해야 합니다.
4. 백트래킹에서의 재귀 활용
**백트래킹(Backtracking)**은 모든 가능한 해를 탐색하는 완전 탐색 알고리즘의 한 기법으로, 해를 찾는 과정에서 조건에 맞지 않으면 되돌아가서 다른 가능성을 탐색하는 방법입니다. 현재 상태에서 취할 수 있는 모든 선택지를 따라 들어가며 탐색하다가, 조건에 어긋나면 즉시 이전 상태로 돌아(backtrack)서 다른 선택지를 시도합니다​
JUN-N.TISTORY.COM
​
JUN-N.TISTORY.COM
. 이러한 탐색 과정은 트리 형태의 상태 공간 탐색으로 볼 수 있는데, 재귀 호출은 이 과정을 구현하기에 매우 적합합니다. 재귀 함수를 이용하면 함수의 호출 스택이 자연스럽게 상태 공간 트리의 경로를 표현해주고, 함수가 종료될 때 자동으로 이전 상태로 복귀(backtrack)하게 되므로 코드가 간결해집니다.백트래킹은 구현 시 재귀적 구조를 띠는 것이 일반적이며, 백트래킹 알고리즘의 골자는 다음과 같습니다:
결과 찾기: 현재 단계에서 해답을 찾았는지 검사합니다. (재귀 함수의 기본 단계에 해당)
가능한 선택 탐색: 해답이 아니면, 현재 상태에서 취할 수 있는 모든 선택지를 순회합니다.
재귀 호출: 각 선택지를 하나 수행하고 나서 다음 단계로 재귀 호출을 합니다.
백트랙(backtrack): 재귀 호출이 끝나면 (해당 선택지의 탐색이 끝나면) 이전 상태로 돌아와서 다음 선택지를 시도합니다. (필요하다면 상태를 원상복구하여 복귀)
이러한 흐름은 재귀 호출의 진행과 복귀가 자연스럽게 백트래킹의 탐색과 되돌아옴을 처리해줍니다.
N-Queens 문제: 백트래킹의 대표적인 예제로 자주 언급되는 문제가 N-퀸 문제입니다. 이 문제는 $N \times N$ 체스판 위에 N개의 퀸을 서로 공격할 수 없도록 놓는 모든 방법을 찾는 것입니다​
TEAR94FALL.GITHUB.IO
. 퀸은 체스 말 중 하나로, 서로 같은 행(row), 같은 열(column), 또는 대각선 방향으로 놓이면 공격 관계가 발생합니다. 백트래킹을 활용하면 한 행씩 퀸을 놓아가면서, 중간에 충돌 조건이 발생하면 바로 이전 단계로 되돌아가서 다음 위치에 놓는 식으로 모든 배치를 탐색할 수 있습니다. 재귀 함수 solve_queen(row)를 정의하여 row번째 행에 퀸을 놓는 로직을 구현할 수 있습니다. 대략적인 알고리즘은 다음과 같습니다:
기본 단계: 만약 row == N이면 N개의 퀸을 모두 놓은 것이므로 해답을 찾은 것입니다. 해답을 기록하거나 출력합니다.
재귀 단계: 그렇지 않다면, 현재 행 row에서 모든 열 col을 순회하며 퀸을 놓아봅니다.
해당 위치 (row, col)에 퀸을 놓을 수 있는지 검사합니다 (이전에 놓은 퀸들과 충돌하지 않는지 체크).
놓을 수 있다면 퀸을 그 위치에 배치하고, 재귀적으로 solve_queen(row+1)을 호출하여 다음 행에 퀸을 놓습니다.
재귀 호출이 끝나면 (다음 행의 처리가 완료되면) 현재 행에서 놓았던 퀸을 치우고(backtrack) 다음 열 위치로 이동합니다.
이 알고리즘을 재귀로 구현하면, row가 증가하며 재귀 호출이 깊어지고, 충돌 발견 시 재귀 호출이 끝나면서 자동으로 직전 상태로 돌아오는 구조가 됩니다. 백트래킹을 쓰면 모든 가능한 퀸 배치를 탐색할 수 있지만, $N$ 값이 커지면 경우의 수가 폭발적으로 늘어나므로 가지치기(pruning) 조건을 잘 활용해야 합니다.
부분 집합 생성 (Power Set): 또 다른 예제로, 주어진 집합에서 모든 **부분 집합(subset)**을 생성하는 문제를 생각해봅시다. 예를 들어 입력 집합이 {1, 2, 3}이라면 공집합 []부터 시작하여 원소를 모두 담은 집합까지 총 $2^N$개의 부분 집합을 만들게 됩니다. 이 문제 역시 재귀와 백트래킹으로 간단히 해결할 수 있습니다. 각 원소를 포함하거나 포함하지 않는 두 가지 선택지로 분기하면서 재귀 호출을 하면 모든 조합을 탐색하게 됩니다. 부분 집합을 만드는 재귀 알고리즘은 다음과 같습니다:
python
복사
편집
def generate_subsets(arr, index=0, current=None):
    if current is None:
        current = []
    # 기본 단계: 모든 원소를 검사한 경우, 현재 부분집합 출력 or 저장
    if index == len(arr):
        print(current)  # 부분 집합 하나 완료 (필요에 따라 수집 가능)
        return
    # 재귀 단계 1: 현재 원소를 포함하지 않는 경우
    generate_subsets(arr, index + 1, current)
    # 재귀 단계 2: 현재 원소를 포함하는 경우
    current.append(arr[index])
    generate_subsets(arr, index + 1, current)
    current.pop()  # 백트래킹: 다음 branch 위해 상태 복원
위 함수에서 index는 현재 처리 중인 원소의 인덱스이고, current는 지금까지 선택한 원소들로 구성된 부분 집합입니다. 재귀를 돌면서 index가 배열 길이에 도달하면 하나의 부분 집합이 완성된 것이므로 출력합니다. 그렇지 않으면, 해당 인덱스의 원소를 포함하지 않는 경우와 포함하는 경우로 나누어 재귀 호출합니다. 두 번째 재귀 호출 후에는 current에 추가했던 원소를 pop()하여 이전 상태로 되돌리는 것이 백트래킹의 핵심입니다. 이 로직을 통해 모든 부분 집합이 생성되며, 호출 트리는 이진 트리 형태로 전개됩니다. 예를 들어 {1,2}에 대해 부분 집합을 구하면 재귀 호출의 흐름은 대략 다음과 같습니다.
[] (시작 상태)
원소 1 불포함 -> []
원소 2 불포함 -> [] (완성된 부분집합 하나)
원소 2 포함 -> [2] (완성된 부분집합 하나)
원소 1 포함 -> [1]
원소 2 불포함 -> [1] (완성된 부분집합 하나)
원소 2 포함 -> [1, 2] (완성된 부분집합 하나)
이처럼 재귀와 백트래킹을 사용하면 부분 집합, 순열, 조합 등의 모든 경우의 수를 간결한 코드로 생성할 수 있습니다. 각각의 재귀 호출은 선택을 확장하는 역할을 하고, 함수가 종료되면 선택을 철회(백트래킹)하여 다른 가능성을 탐색합니다.
5. 재귀 사용 시 주의사항 (한계 및 최적화)
재귀는 강력한 도구이지만 잘못 사용하면 문제를 일으킬 수 있으므로 다음 사항들을 항상 유의해야 합니다:
명확한 기본 단계 설정: 재귀 함수에는 반드시 종료 조건이 되는 기본 단계가 있어야 합니다. 기본 단계가 없거나 잘못 설정되면 함수가 무한정 자신을 호출하게 되어 스택 오버플로우나 무한 루프에 빠집니다​
JTODAY.TISTORY.COM
. 구현 시에는 재귀 호출 전에 종료 조건을 한 번 더 점검하고, 모든 입력에 대해 재귀 호출이 끝날 수 있는지 논리적으로 확인해야 합니다. 예를 들어 잘못 구현된 def countdown(n): print(n); countdown(n-1) 함수는 종료 조건이 없어 결국 무한 호출로 이어지니, if n <= 0: return 같은 종료 조건을 반드시 넣어야 합니다.
스택 깊이 한계: 재귀 호출은 프로세스 스택 메모리를 소비하므로, 호출이 너무 깊어지면 언어별 제한에 걸릴 수 있습니다. 파이썬의 경우 재귀 호출 깊이 제한이 기본적으로 1000으로 정해져 있으며, 이를 초과하면 RecursionError: maximum recursion depth exceeded 예외가 발생합니다​
PYTHONCENTRAL.IO
. 이 한계는 sys.setrecursionlimit으로 조절 가능하지만, 인위적으로 늘리는 것은 권장되지 않습니다. C/C++이나 자바에서는 명시적 제한은 없지만, 결국 스택 메모리가 소진되면 프로그램이 뻗거나 StackOverflowError가 발생합니다. 따라서 너무 깊은 재귀는 지양하고, 필요한 경우 알고리즘을 재구성하거나 반복문으로 전환하는 것을 고려해야 합니다.
성능 고려: 재귀는 함수 호출의 오버헤드가 누적되므로 반복문 대비 성능이 떨어질 수 있습니다​
MELONICEDLATTE.COM
. 특히 단순한 계산을 매우 많은 횟수 반복하는 경우라면 재귀보다는 반복문이 적합합니다. 또한 재귀 알고리즘의 시간 복잡도가 높은 경우(예: naive 피보나치 $O(2^n)$) 입력 크기에 주의해야 합니다. 메모이제이션이나 동적 계획법으로 성능 개선이 가능하다면 적극 활용하세요. 예컨대, 코딩 테스트에서 재귀로 조합 계산을 구현해야 할 때 중복 부분은 메모이제이션으로 제거하지 않으면 시간 초과가 날 수 있습니다. 항상 재귀 호출 횟수와 중복 작업 여부를 염두에 두고 최적화를 고민해야 합니다.
언어 특성 이해: 앞서 언급했듯이 꼬리 재귀 최적화는 언어마다 지원 여부가 다릅니다. Python이나 Java는 자동 최적화를 지원하지 않으므로 꼬리 재귀라도 일반 재귀와 다름없이 동작합니다. 반면 Scheme, Scala, Clojure 등 함수형 프로그래밍 언어나 일부 컴파일러는 꼬리 호출을 최적화하여 스택을 늘리지 않고 반복처럼 처리해줍니다​
CATSBI.OOPY.IO
. 사용 중인 언어의 재귀 최적화 특성을 알고 있어야 하며, Python처럼 최적화가 없는 경우 깊은 꼬리재귀는 여전히 문제가 될 수 있음을 유념하세요. 필요하면 재귀를 명시적인 반복이나 스택 이용 코드로 변환하는 것도 한 방법입니다.
디버깅과 가독성: 재귀 코드는 논리가 잘못되면 어디서 끝나지 않고 반복되는지 추적하기 어려울 때가 있습니다. 디버거를 사용할 때도 함수가 여러 번 중첩 호출되므로 호출 스택을 면밀히 봐야 합니다. 따라서 재귀를 사용할 때는 함수의 역할과 매개변수 변화를 명확히 해두고, 필요하면 중간 상태를 로깅하거나 출력하여 동작을 확인하는 것이 좋습니다. 또한 동료 개발자가 이해하기 쉽도록 주석을 활용해 재귀 관계(특히 백트래킹의 경우 선택과 백트랙 부분)를 설명하면 가독성 측면에서 도움이 됩니다.
요약하자면, 재귀 사용 시에는 "이 재귀 호출이 반드시 끝나는가?", *"호출 회수를 감당할 수 있는가?"*를 스스로 확인해야 합니다. 작은 입력에 대해 올바로 동작하고, 큰 입력에 대해서도 성능과 메모리가 허용되는지를 고려해야 하며, 그렇지 않다면 반복적 접근으로 변경하거나 추가 최적화를 해야 합니다.
6. 실전 코딩 테스트 예제
마지막으로, 재귀와 백트래킹이 실제 코딩 테스트나 알고리즘 문제에서 어떻게 활용되는지 몇 가지 대표 문제 유형을 소개합니다. 아래 예시들은 모두 재귀를 활용하여 해결할 수 있으며, 중급 개발자라면 한 번쯤 구현해보거나 접해봤을 만한 문제들입니다:
팩토리얼(Factorial) – 간단한 재귀의 예제로, n! 값을 구하는 문제입니다. 기본 단계와 재귀 단계의 개념을 익히기에 좋습니다.
피보나치 수열(Fibonacci) – 재귀와 동적 계획법을 비교할 때 자주 언급되는 예제입니다. 재귀의 중복 계산 이슈와 메모이제이션의 필요성을 체감할 수 있습니다.
하노이의 탑(Tower of Hanoi) – 3개의 기둥을 이용해 N개의 원판을 옮기는 고전적인 퍼즐로, 재귀적 패턴이 명확히 드러나는 문제입니다. 이동 단계의 규칙을 재귀식으로 정의하여 풀이합니다.
이진 트리 순회(Binary Tree Traversal) – 이진 트리의 전위순회, 중위순회, 후위순회 등을 재귀로 간결하게 구현할 수 있습니다. 트리 구조가 재귀적 특징을 가지기 때문에, 재귀 호출이 노드 방문에 자연스럽게 쓰입니다.
그래프 DFS(Depth-First Search) – 그래프나 2D 격자의 깊이우선탐색을 재귀로 구현하는 경우가 많습니다. 예를 들어 미로 탐색, 섬의 개수 찾기 등의 문제에서 재귀 DFS를 사용하면 코드가 짧고 이해하기 쉽습니다.
N-Queen 문제 – 앞서 설명한대로 백트래킹의 전형적인 문제로, 재귀를 사용해 모든 퀸 배치를 탐색합니다. 가지치기 조건을 얼마나 효율적으로 넣는지가 관건인 어려운 문제입니다.
순열 생성(Permutations) – 주어진 배열이나 문자열의 모든 순열을 생성하는 문제입니다. 백트래킹으로 각 위치에 들어갈 값을 선택하면서 재귀 호출을 수행하고, 한 분기(branch)의 처리가 끝나면 되돌아와 다음 값을 시도하는 방식으로 전부 탐색합니다.
부분 집합 및 조합 생성(Subsets & Combinations) – 부분 집합 생성 문제처럼, n개 아이템 중 k개를 뽑는 모든 조합을 찾는 문제 등에 재귀가 활용됩니다. 반복문으로 작성하기 복잡한 다중 루프를 재귀로 깔끔하게 대체할 수 있습니다.
Sudoku 풀이 등 백트래킹 응용 – 스도쿠 같은 퍼즐을 푸는 문제는 백트래킹으로 해결 가능합니다. 한 칸씩 숫자를 채워나가다가 조건에 어긋나면 이전 단계로 돌아가 다른 숫자를 시도하는 식의 재귀적 백트래킹이 전형적으로 적용됩니다.
以上의 예제들은 재귀 및 백트래킹을 훈련하기에 좋은 문제들입니다. 코딩 테스트에서는 이처럼 완전 탐색이 필요한 문제나 재귀적으로 정의된 문제가 출제될 수 있으므로, 재귀 함수를 작성하고 최적화하는 연습을 충분히 해두는 것이 좋습니다. 특히 백트래킹 유형의 문제는 재귀 호출 구조를 익혀 두면 해결에 큰 도움이 됩니다. 마지막으로, 재귀를 사용할 때는 항상 앞서 언급한 원칙(기본 단계 명확히, 종료 조건 확인, 최적화 가능성 등)을 염두에 두면서 코드를 작성하면 더욱 안정적이고 효율적인 프로그램을 만들 수 있을 것입니다.
