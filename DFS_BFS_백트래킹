C++ 코딩 테스트 강의안 (스택, 큐, DFS, BFS, 백트래킹)
대상: 대학 3학년 수준의 한국 학생 (프로그래머스 문제 활용)
목표: 문제 해결 능력 향상 (70%) + 코딩 테스트 실전 대비 (30%)
진행 방식: 코드 구현을 직접 제시하기보다는 어떤 코드 로직이 필요한지 설명하면서 이끌어갑니다.
1. 스택과 큐의 개념 및 STL 사용법
**스택(Stack)**은 후입선출 (LIFO, Last In First Out) 구조의 자료구조입니다​
SARAH950716.TISTORY.COM
. C++에서는 <stack> 헤더를 통해 std::stack 컨테이너 어댑터를 사용할 수 있습니다. 주요 연산으로는 요소 추가 push(), 제거 pop(), 최상단 요소 접근 top() 등이 있습니다​
SARAH950716.TISTORY.COM
. 스택 사용 시 주의할 점은, 스택이 비어있을 때 top()이나 pop()을 호출하면 오류가 발생하므로 항상 비어있는지 (empty()) 확인해야 합니다.**큐(Queue)**는 선입선출 (FIFO, First In First Out) 구조의 자료구조입니다​
SARAH950716.TISTORY.COM
. <queue> 헤더의 std::queue를 통해 사용할 수 있으며, 주요 연산으로는 요소 추가 push() (또는 emplace()), 제거 pop(), 가장 앞/뒤 요소 확인 front(), back() 등이 있습니다​
SARAH950716.TISTORY.COM
​
SARAH950716.TISTORY.COM
. 큐 역시 비어 있을 때 front()나 pop() 사용에 주의해야 합니다. std::deque가 기본 컨테이너로 쓰이므로 양쪽 끝에서의 삽입/삭제가 효율적입니다.**우선순위 큐(Priority Queue)**는 항상 최대값 또는 최소값이 먼저 나오는 특수한 큐입니다. C++ <queue> 헤더의 std::priority_queue로 제공되며, 기본 설정에서는 큰 값이 top에 오는 최대 힙 구조입니다. push(), pop(), top() 인터페이스를 제공하며, 내부적으로 자동 정렬되어 가장 우선순위 높은 요소를 빠르게 접근할 수 있습니다. 필요에 따라 비교 함수를 커스터마이징하여 최소 힙 등으로 사용할 수 있습니다. 우선순위 큐를 사용할 때는 많이 삽입될 경우 정렬 비용이 있으므로 N개 항목에 대해 O(N log N)의 복잡도가 생긴다는 점을 유의합니다.실전 문제 유형: 스택은 함수 호출의 역사 관리, 괄호 짝맞추기, 후위표기법 계산 등 후입선출이 필요한 상황에 활용됩니다. 큐는 너비 우선 탐색(BFS)처럼 선입선출 순서가 필요한 상황이나, 순차적으로 처리해야 하는 작업 관리 등에 자주 활용됩니다​
SARAH950716.TISTORY.COM
. 예를 들어, 프로그래머스 올바른 괄호 문제는 문자열의 괄호 짝이 올바른지 검사하는데 스택을 활용합니다 (여는 괄호 (를 스택에 넣고 닫는 괄호 )가 나오면 스택에서 꺼내는 방식). 프로그래머스 기능개발 문제는 작업 진도와 속도가 주어졌을 때 기능 출시 일자를 계산하는 시뮬레이션으로, 작업들을 큐에 넣고 순서대로 완료 여부를 확인합니다. 프로그래머스 프린터 문제는 중요도 순으로 문서를 출력하는 시나리오로, 중요도가 높은 문서를 먼저 처리하기 위해 **큐와 priority_queue**를 함께 사용하여 구현합니다. 이러한 예시들을 통해 스택/큐의 사용법과 효용을 파악합니다.
2. 스택과 DFS의 관계
DFS(Depth First Search, 깊이 우선 탐색)는 자료구조적으로 스택을 활용하여 동작합니다. 재귀 함수를 이용한 DFS는 시스템 호출 스택을 활용하는 것이고, 반복문으로 구현할 때는 직접 std::stack을 사용할 수 있습니다. DFS에서는 한 경로를 가능한 깊이 끝까지 탐색한 후에야 다른 경로로 돌아오는데, 이 후입선출 특성이 스택과 일치합니다​
SARAH950716.TISTORY.COM
. 즉, 마지막에 진입한 분기부터 먼저 탐색을 마치고 돌아오는 방식으로, 함수 호출이 중첩되었다가 반환되는 과정(백트래킹)이 스택 구조로 이루어집니다.구현 측면: 재귀 DFS 시에는 종료 조건을 명확히 정해 무한 재귀에 빠지지 않도록 해야 하고, 필요한 경우 전역/지역 변수를 잘 관리해야 합니다. 스택으로 구현하는 DFS에서는 stack.push(시작노드), 루프 내에서 stack.top()을 꺼내 처리(pop())하고, 방문하지 않은 인접 노드를 다시 push()하는 식으로 구현합니다. 이때 방문 여부를 체크하는 visited 배열/벡터가 필수적입니다 (중복 방문으로 인한 무한 loop 방지). 또한 재귀 DFS는 스택 오버플로우를 주의해야 합니다. 특히 그래프 깊이가 매우 깊으면 재귀 호출이 스택 메모리를 초과할 수 있으므로 (C++에서는 기본적으로 재귀가 너무 깊어지면 위험) 필요시 반복문+스택으로 대체하거나 꼬리 재귀 최적화가 안되므로 입력 크기에 따른 안전 여부를 판단해야 합니다​
VELOG.IO
.대표적인 문제 유형: 그래프 탐색에서 연결 요소 찾기, 경로 찾기 등에 DFS가 자주 사용됩니다. 예를 들어, 프로그래머스 네트워크 문제는 컴퓨터 네트워크 연결 요소 개수를 찾는 문제로, 방문되지 않은 노드에 대해 DFS를 수행하여 한 컴포넌트를 모두 탐색하고 연결 개수를 세는 방식으로 해결할 수 있습니다. 또한 백트래킹 유형의 문제들도 내부적으로는 DFS 로직을 사용합니다 (예: 모든 가능한 경우를 탐색하는 퍼즐이나 조합 생성). 단순한 DFS를 활용한 예로 프로그래머스 타겟 넘버 문제가 있습니다. 이 문제에서는 주어진 숫자들에 +혹은 -를 할당하여 타겟 합을 만드는 모든 경우를 찾는데, DFS 재귀를 통해 각 숫자를 더하거나 빼는 두 가지 분기를 끝까지 탐색합니다. 이러한 탐색 과정은 실제로 이진 트리를 DFS로 순회하는 것과 같으며, 재귀 호출 스택을 사용한 전형적인 DFS 예시입니다. 이처럼 그래프 탐색, 부분 집합 또는 조합 탐색 등에서는 스택 (혹은 재귀)을 활용한 DFS가 기본 도구입니다.프로그래머스 문제 사례:
타겟 넘버: DFS를 이용해 모든 경우의 합을 탐색 (재귀 호출을 통한 스택 사용).
네트워크: 인접 리스트/행렬로 표현된 그래프에서 DFS로 연결된 컴퓨터 그룹 탐색.
여행경로: 주어진 항공 티켓으로 만들 수 있는 여행 경로를 찾는 문제로, 모든 경로를 깊이 우선으로 시도해보고 조건에 맞지 않으면 돌아오는 DFS+백트래킹 기법을 사용 (가능한 경로를 스택처럼 쌓았다가 티켓을 다 사용 못하면 백트랙).
3. 큐와 BFS의 관계
BFS(Breadth First Search, 너비 우선 탐색)는 큐를 활용하여 구현되는 탐색 방법입니다. 시작점으로부터 가까운 이웃들을 먼저 탐색하고 차츰 멀리 있는 노드를 탐색하는 방식으로, FIFO 구조인 큐를 사용해 탐색 순서를 관리합니다​
SARAH950716.TISTORY.COM
. BFS 구현에서는 std::queue를 사용하며, 시작 노드를 push()한 후 큐가 빌 때까지 반복합니다. 매 반복마다 queue.front()를 꺼내(pop()) 해당 노드와 인접한 노드들을 모두 큐에 넣어 탐색을 이어갑니다. 이렇게 하면 먼저 들어간 노드의 이웃들을 먼저 처리하므로, 탐색이 계층(level) 순서로 진행됩니다.BFS는 최단 경로를 찾는 데 유용합니다. 가중치가 없는 그래프나 격자(grid)에서 두 지점 사이의 최단 이동 경로를 구할 때 BFS를 쓰면, 먼저 발견되는 경로가 곧 최단 경로가 됩니다​
CSY7792.TISTORY.COM
. 이는 BFS가 거리 순으로 탐색을 확장하기 때문에 가능한 특성입니다. 다만 BFS는 동시에 많은 노드를 메모리에 담아두고 탐색하므로 경로가 길거나 그래프가 클 경우 메모리 사용량이 증가할 수 있습니다​
CSY7792.TISTORY.COM
. 구현 시에는 각 노드를 한 번만 탐색하도록 visited 표시를 해야 불필요한 중복 탐색을 막고 성능과 메모리를 아낄 수 있습니다. 또한, 큐에 넣을 때 방문 표시를 바로 하거나 큐에 넣은 직후 하는 것이 중요합니다. 그래야 이미 큐에 넣은 노드를 또 넣지 않으며 무한 루프를 방지합니다.대표적인 문제 유형: 최단 거리 문제나 레벨 단위 탐색이 필요한 경우 BFS가 적합합니다. 예를 들어, 프로그래머스 게임 맵 최단거리 문제는 2D 격자 맵에서 상대 팀 진영까지의 최단 거리를 찾는 문제로, BFS를 사용하면 출발 지점에서 가까운 칸부터 차례로 탐색하여 벽을 피해 목표 지점까지의 최단 이동 횟수를 구할 수 있습니다. 또한 프로그래머스 단어 변환 문제는 한 단어를 다른 단어로 바꾸는데 필요한 최소 변환 횟수를 묻는데, 이는 각 단어를 노드로 보고 한 글자만 다른 단어끼리 간선을 연결한 그래프로 생각하여 BFS로 최단 변환 과정을 찾을 수 있습니다. 이처럼 미로 탐색, 거리 계산, 계층별 처리가 언급된 문제는 BFS가 자연스럽게 떠오릅니다. BFS는 이진 트리의 레벨 순회 (level order traversal)에도 사용되며, 트리의 너비를 구하거나 각 레벨별 노드를 처리할 때도 쓰입니다. 프로그래머스에는 없지만 예를 들어 BOJ 미로 탐색 문제에서도 BFS로 최단거리를 찾는 전형적인 예시입니다.프로그래머스 문제 사례:
게임 맵 최단거리: 격자에서 최단 경로 탐색 – BFS로 단계별 탐색하여 해결.
단어 변환: 시작 단어에서 목표 단어로 한 글자씩 바꾸는 최단 과정 – 그래프 모델링 후 BFS.
아이템 줍기: 직사각형 경계로 이루어진 맵에서 아이템까지의 최단 거리 – 장애물을 피해 BFS로 거리 탐색.
네트워크: (DFS로도 풀 수 있지만) BFS로 각 컴퓨터 연결요소를 탐색하여 해결 가능 (큐 사용).
4. DFS와 BFS의 차이점 및 활용법
DFS와 BFS는 모두 그래프나 트리 탐색에 쓰이지만, 탐색 순서와 전략의 차이로 인해 장단점과 활용처가 다릅니다. DFS는 한 경로를 정하면 끝까지 파고들었다가 더 이상 갈 곳이 없으면 되돌아오는 식으로 탐색합니다​
VELOG.IO
. BFS는 시작 지점에 인접한 모든 지점을 먼저 탐색하고, 그 다음 단계로 넘어가는 방식으로 진행됩니다​
VELOG.IO
. 이 차이 때문에 DFS는 깊이, BFS는 너비를 우선으로 한다고 요약할 수 있습니다.
해결 능력: DFS는 경로를 따라가며 목표를 찾는 문제에서 유용하며, 해를 찾으면 바로 종료할 수 있다는 장점이 있습니다. 예를 들어 경로 존재 여부처럼 찾으면 끝인 경우에는 굳이 모든 경로를 다 볼 필요 없이 DFS로도 충분합니다. 반면 BFS는 해를 찾더라도 계속해서 같은 거리에 있는 다른 노드들을 모두 확인하기 때문에 일반적으로 DFS보다 탐색 진행 자체는 느릴 수 있습니다. 그러나 BFS는 탐색을 단계별로 진행함으로써 최단 경로를 보장한다는 중요한 장점이 있습니다​
CSY7792.TISTORY.COM
. 최단거리 문제에서는 DFS로 모든 경로를 확인한 뒤 최단을 고르는 것보다 BFS로 한번에 찾는 것이 효율적입니다.
메모리 및 구현: DFS는 재귀 또는 스택 기반으로 구현되며, 현재 탐색 경로 외에는 많은 정보를 저장하지 않아 메모리 사용량이 비교적 적습니다​
VELOG.IO
. 하지만 최악의 경우 깊이가 매우 깊어지면 스택 오버플로우 위험이나 불필요하게 한쪽 경로로만 너무 깊이 들어가는 문제가 생길 수 있습니다. BFS는 모든 이웃을 큐에 저장하면서 탐색하기 때문에 한꺼번에 유지해야 하는 노드가 많아 메모리를 더 사용할 수 있습니다​
VELOG.IO
. 예를 들어 그래프가 큰 경우 BFS로 한 단계 전체를 큐에 넣으면 공간 소모가 큽니다. 구현 난이도 측면에서는, DFS는 재귀로 간결하게 작성할 수 있어 비교적 코드가 단순한 반면 BFS는 큐를 사용해 반복문을 돌리는 형태로 좀 더 많은 코드량이 필요할 수 있습니다​
CSY7792.TISTORY.COM
.
활용 전략: 최단 거리나 층별 결과가 필요한 문제는 BFS를 우선 고려합니다. 예를 들어 "몇 단계 만에 도달 가능한가?"를 묻는 문제는 BFS가 적합합니다. 해가 하나라도 나오면 되는 경우나 모든 해를 찾아야 하는 경우에는 DFS가 유리합니다. 모든 해를 찾을 때 BFS도 가능하지만 불필요하게 넓게 탐색하므로 비효율적일 수 있습니다. 또, 해답이 존재하지 않을 가능성이 있는 경우 메모리 문제가 없다면 BFS는 모든 가능성을 층별로 확인하고 없음을 검증하지만, DFS는 운이 나쁘면 해가 없는데도 한쪽 깊이로 무한 탐색에 빠질 수도 있으니 사이클이 있는 그래프에서는 방문체크 등 보완이 필요합니다.
요약하면, **“최단”**이라는 키워드가 보이면 BFS, **“완전 탐색”**이나 경로 존재 검사 등은 DFS를 먼저 생각합니다. 다만 많은 경우 DFS와 BFS는 서로 대체 가능하며, 구현의 용이성과 효율을 맞춰 선택하면 됩니다. 실제 코딩 테스트에서도 DFS로 풀 수 있는 문제를 BFS로 풀어도 정답이거나 그 반대도 종종 있으므로, 두 방법을 모두 이해하고 있는 것이 중요합니다. 문제에 주어진 조건(그래프 크기, 경로 조건 등)에 따라 적절히 선택하는 연습을 합니다.
5. DFS와 백트래킹의 차이점 및 활용법
DFS와 백트래킹은 모두 깊이 우선적 탐색 기법이지만, 가리키는 개념의 범위와 쓰임새에 차이가 있습니다. DFS는 주로 그래프나 트리 구조에서 모든 노드를 한 번씩 방문하기 위한 알고리즘을 뜻합니다. 즉, 경로를 따라 내려가며 노드를 방문하고 막히면 되돌아오는 일반적인 탐색 방법입니다. **백트래킹(Backtracking)**은 해를 찾는 과정에서 조건에 맞지 않는 경로는 더 깊이 가지 않고 되돌아오는 (Prune & Search) 기법을 말합니다. 백트래킹은 어떤 의미에서는 DFS를 활용한 전략이라고 볼 수 있습니다. 실제로, “모든 경우의 수”를 탐색해야 하는 문제에서 불필요한 부분을 가지치기하며 탐색하는 과정은 DFS + 조건 검사의 형태를 띱니다. 컴퓨터 과학 이론적으로도 DFS는 트리/그래프 탐색의 한 형태이고, 백트래킹은 해를 찾기 위해 모든 가능성을 탐색하는 일반 기법이라고 할 수 있습니다​
STACKOVERFLOW.COM
. 쉽게 말해, 백트래킹은 “해를 찾기 위해 후보를 하나 선택하고, 조건에 맞지 않으면 되돌아가서 다음 후보를 시도하는” 과정이며, 이때 탐색 순서는 깊이 우선을 따르므로 내부적으로 DFS를 사용한다고 이해하면 됩니다​
STACKOVERFLOW.COM
.차이점 정리: DFS는 경로가 유효하든 아니든 일단 끝까지 갔다 돌아오는 순회 자체에 중점을 두고, 백트래킹은 유효하지 않은 경로는 더 깊이 탐색하지 않음에 중점을 둡니다. 백트래킹은 보통 상태공간 트리를 구성하여 정답이 될 것 같지 않은 가지는 조기에 포기함으로써 전체 탐색 공간을 줄이는 효과가 있습니다. 따라서 백트래킹은 제약 조건이 많은 완전 탐색 문제에 특히 유용하며, 문제의 조건에 따라 “이런 경우는 해가 될 수 없다”는 판단이 들면 그 분기를 즉시 종료하고 다음 분기를 시도합니다. 구현면에서는 DFS의 재귀를 기반으로 함수 호출 전후에 상태를 기록/복원(undo)하는 코드가 추가되는 형태입니다. 예를 들어 전역 또는 외부 상태를 변경하고 재귀호출 후에 원상 복구하는 패턴(visit[i] = true; dfs(...); visit[i] = false;)이 전형적인 백트래킹 코드 구조입니다. 가지치기(pruning) 조건을 잘 설정하면 백트래킹의 효율이 크게 올라가며, 이는 DFS를 단순히 했을 때의 지수폭발적 탐색을 많이 줄여줍니다.대표적인 문제 유형: 퍼즐 풀기나 조합 최적화 문제에서 백트래킹이 활용됩니다. 예를 들어, N-Queen 문제(가로세로 대각선 충돌 없이 N개의 퀸 놓기)는 전형적인 백트래킹 문제로, 한 행씩 퀸을 놓아가다가 충돌 조건이 발생하면 바로 이전 단계로 되돌아와(next) 다른 위치에 놓는 식으로 진행합니다. 순열, 조합 생성 문제들도 백트래킹으로 풀이합니다. 코딩 테스트 관점에서 보면, 프로그래머스 여행경로 문제는 주어진 항공권을 사용해 모든 도시를 방문하는 경로를 찾는 것으로, 가능하지 않은 경로는 빨리 포기하고 다음 경로를 시도하는 백트래킹이 필요합니다. 또한 프로그래머스 불량 사용자 문제는 제재 아이디 목록에 매칭되는 사용자 조합을 찾는 것으로, 가능한 사용자 조합을 모두 탐색하되 일치하지 않는 경우 가지치기하는 백트래킹으로 해결할 수 있습니다. 프로그래머스 소수 찾기 (주어진 숫자들로 만들 수 있는 모든 조합의 수 중 소수 개수 찾기) 역시 백트래킹으로 모든 숫자 조합을 생성하고 소수 여부를 체크하는 방식입니다. 이처럼 경우의 수 탐색 + 제약 조건이 있는 문제에서 백트래킹 전략이 쓰이며, 구현은 DFS를 기반으로 합니다.
6. 이 주제를 공부하는 학생들이 알면 좋은 인사이트
효율적인 탐색을 위한 팁: DFS, BFS, 백트래킹을 사용할 때는 시간 복잡도와 검색 공간 크기를 항상 염두에 두어야 합니다. BFS/DFS로 그래프를 탐색하는 경우 보통 O(V+E)의 시간으로 충분하지만, 백트래킹으로 N개의 요소를 전부 탐색하면 최악의 경우 O(branch^depth) (예: 순열 n! 혹은 2^n) 수준이 될 수 있습니다. 따라서 문제의 입력 크기를 보고 어느 정도까지 완전 탐색이 가능한지 판단해야 합니다. 예를 들어, 백트래킹으로 순열을 생성하는 문제에서 n=10이면 10! = 3,628,800 가지로 충분히 가능하지만 n=15이면 15! > 1조 가지로 불가능하므로 다른 최적화가 필요합니다. 이러한 판단력을 기르기 위해 연습 문제를 풀 때 입력 범위에 따른 알고리즘 선택 연습을 합니다.재귀와 반복 구현: DFS/백트래킹은 재귀로 구현하는 경우가 많습니다. C++에서 재귀 호출시 호출 스택 크기 한계를 주의해야 하며, 특히 깊거나 많은 재귀가 예상되면 반복문 + 명시적 스택으로 전환하거나 tail recursion으로 바꿀 수 있는지 고민합니다. 또한 반복문으로 구현하면 스택 메모리 문제는 없지만 코드가 다소 복잡해질 수 있으므로, 적절한 균형을 찾는 연습도 필요합니다. 반복 BFS의 경우는 주로 Queue를 사용하므로 재귀적이지 않지만, BFS를 재귀로 구현하는 경우는 거의 없다는 것도 짚어줍니다.메모리와 방문 처리: 그래프 탐색에서는 **방문 표시(visited)**의 중요성을 강조합니다. visited 배열이나 map을 사용하여 이미 방문한 노드를 다시 방문하지 않도록 해야 DFS/BFS 모두에서 무한 루프 방지와 중복 연산 제거가 가능합니다. 백트래킹에서는 방문 표시뿐만 아니라 현재 선택한 요소의 취소(undo) 작업도 중요합니다. 예를 들어 어떤 경로를 선택해 들어갔다가 돌아올 때, 선택 상태를 원복하지 않으면 다음 경로 탐색에 영향을 주어 오답이 됩니다. 이런 부분을 실수하지 않도록 백트래킹 코드를 작성할 때는 하나의 재귀 호출이 끝날 때 상태를 복구하는 습관을 들입니다.STL 사용상의 주의: C++ STL의 stack, queue, priority_queue 등을 코딩 테스트에서 바로 사용할 수 있다는 점은 큰 장점입니다. 다만 컨테이너 어댑터라는 특성을 알아둡니다. stack과 queue는 내부에 deque 등을 사용해 구현되며, iterator가 없고 size()/empty()/push()/pop()/top()/front()/back() 등의 제한된 인터페이스만 제공합니다. 즉, stack이나 queue 자체를 range-for 문으로 순회할 수 없고, 원소를 중간에서 접근하거나 제거할 수 없습니다. 이러한 제한을 우회해야 하는 경우 deque를 직접 사용할 수도 있습니다. priority_queue는 기본적으로 최대 힙이므로, 최소값 우선으로 가져오려면 커스텀 비교자를 주거나 음수 값을 넣는 트릭을 쓰기도 합니다. 또한 empty일 때 top()을 부르면 안 되고, pop()은 반환값이 없으므로 top()으로 값을 얻은 후 pop()해야 하는 점 등 자잘한 사항을 알고 있어야 실수하지 않습니다​
SARAH950716.TISTORY.COM
.패턴과 트릭:
그래프 표현: 인접 리스트(vector<vector<int>> graph;)를 만들어 두면 DFS/BFS 구현이 편리합니다. 또한 노드 방문 여부를 표시하는 vector<bool> visited;를 함께 관리합니다.
DFS 스택 활용: 재귀 대신 스택을 써야 할 경우, 구조체나 페어를 스택에 넣어 상태를 저장하는 방법을 씁니다 (예: (node, depth)를 push 해서 깊이 정보까지 관리).
BFS 큐 활용: 큐에 노드를 넣을 때 거리나 단계가 중요하면 큐에 (node, dist) 형태의 자료구조를 함께 넣어 관리합니다. 또는 거리 배열 dist[]를 따로 유지하는 방법도 있습니다.
백트래킹 가지치기: 백트래킹에서는 조건문을 통해 불필요한 재귀 호출을 하지 않는 것이 핵심입니다. 예를 들어 합이 이미 목표보다 크면 더 이상 들어가지 않기, 남은 아이템 수로 최대로 늘려도 현재 최적해보다 못하면 가지치기 등 휴리스틱을 적용할 수 있습니다. 이러한 가지치기 조건은 문제별로 달라지며, 제약을 활용하는 사고력을 키우는 것이 중요합니다.
예상 질문 대비: 스택/큐/DFS/BFS를 쓰는 문제에서는 면접이나 해설에서 “왜 이 방식을 선택했는가?”를 물을 수 있으므로, 선입선출이 필요해서, 최단거리 보장이 필요해서 등 명확한 키워드로 근거를 설명할 수 있도록 합니다. 이는 알고리즘을 선택하는 근거를 자신이 이해했는지를 보여주는 것이기도 합니다.
7. 각 알고리즘 및 자료구조를 사용해야 하는 단서 및 키워드
문제를 읽으면서 어떤 알고리즘이나 자료구조를 떠올려야 할지 판단하는 것은 코딩 테스트 합격의 중요한 요소입니다. 아래는 문제 설명이나 조건에 등장하는 키워드별로, 활용해야 할 알고리즘/자료구조를 연결한 표식들입니다:
"최단 거리", "최소 이동 횟수", "몇 단계" 등 최소 경로를 요구하는 표현이 나오면 BFS를 고려하세요. 예를 들어 "게임 맵 최단거리"처럼 맵에서 최단 경로를 묻거나, 그래프에서 최단 경로 문제인 경우 BFS가 자연스러운 해법입니다​
CSY7792.TISTORY.COM
. (가중치 없는 경우에 한정; 가중치가 있다면 Dijkstra 알고리즘 등이 필요)
"모든 경우", "모든 조합", "완전 탐색" 등의 표현이 있으면 DFS/백트래킹을 의심합니다. 예를 들어 타겟 넘버 문제에서 모든 +/- 조합을 시도한다거나, 여행경로 문제에서 가능한 경로를 전부 따져봐야 할 때 DFS/백트래킹으로 접근합니다. 특히 "만족하는 해를 찾아라", "가능한 경우의 수" 등이 나오면 백트래킹으로 모든 해를 탐색하는 구조를 떠올립니다.
**"OO가 주어졌을 때 가능한지 여부"**처럼 경로 존재 여부나 연결 여부를 묻는 문제는 DFS 또는 BFS로 그래프 탐색을 하면 됩니다. 예를 들어 네트워크 문제에서 두 컴퓨터가 연결되어 있는지 확인하거나, 미로 탐색에서 출구에 도달 가능 여부를 묻는 경우 등이 해당합니다. 이 경우 최단거리까지 필요 없으면 구현이 쉬운 DFS로 충분하고, 거리까지 물으면 BFS로 합니다.
"계층별", "레벨별" 처리 요구나 트리 구조에서 너비 우선 순회를 암시하는 경우는 큐 자료구조(BFS)를 떠올립니다. 예컨대 이진 트리의 레벨별 출력 문제라면 큐로 BFS를 해야 합니다.
"괄호가 올바른지 체크", "문자열 폭발", "가장 최근의 X 처리" 등 후입선출 특성이 필요한 문제는 스택을 사용합니다. 대표적으로 올바른 괄호 문제는 스택으로 여는 괄호를 쌓아두고 닫는 괄호와 짝을 맞추는 방식이 바로 떠오릅니다. 이 밖에 문자열에서 연속된 패턴을 제거하는 문제(예: 짝지어 제거하기)도 스택으로 최근 입력을 추적하며 해결할 수 있습니다.
**"선입선출", "처리 순서대로", "큐를 이용한 처리"**가 언급되거나, 문제 상황이 줄을 서서 기다리는 형태이면 큐를 사용합니다. 예를 들어 프린터 문제는 대기열에서 문서를 순서대로 처리하되 우선순위가 있어 변형된 큐를 쓰는 경우이고, 다리를 지나는 트럭 문제는 트럭들이 들어온 순서대로 다리를 건너는 시뮬레이션이라 기본적으로 큐로 해결합니다.
"우선순위", "가장 ~한 것부터", "정렬된 처리" 등의 키워드는 **우선순위 큐(priority_queue)**를 떠올리세요. 예를 들어 프로그래머스 더 맵게 문제에서는 가장 낮은 두개의 스코빌 지수를 반복해서 합치는 로직이 필요한데, 매번 최소값을 효율적으로 얻기 위해 최소 힙(우선순위 큐)을 사용합니다. 마찬가지로 디스크 컨트롤러 문제도 짧은 작업부터 처리해야 하므로 우선순위 큐로 대기 작업들을 관리합니다.
**"백트래킹"**이라는 단어가 직접 언급된 경우 (일부 문제는 난이도 힌트로 이 단어를 씁니다)나, **"~~하다가 안되면 되돌아간다"**는 식의 서술이 있는 경우는 백트래킹 알고리즘을 적용해야 합니다. 문제 설명에서 검색 공간을 줄이는 제약조건을 설명하는 경우도 백트래킹의 힌트가 됩니다.
입력 크기 힌트: 문제에서 입력 크기를 통해 암시를 주는 경우도 많습니다. 예를 들어 N이 최대 20라면 2^N(약 1백만)을 고려한 완전 탐색도 가능하겠지만, N이 10만이라면 O(N log N)이나 O(N) 해법을 찾아야 합니다. 이럴 때 N이 작으면 백트래킹/완전탐색, N이 크면 BFS/DFS라도 최적화 필요 등의 판단을 합니다. 또한 그래프 간선 수가 매우 많다면 BFS/DFS 시 인접 리스트 활용과 방문체크 최적화가 필요하겠구나 하는 식의 통찰도 가질 수 있습니다.
以上의 키워드와 단서는 많은 연습을 통해 체득하게 됩니다. 강의에서는 각 키워드가 포함된 대표 문제들을 풀어보며, 어떤 생각 과정으로 해당 알고리즘을 선택하는지 자세히 설명할 것입니다. 학생들은 문제를 읽을 때 자연스럽게 “아, 이것은 그때 풀어본 BFS 문제와 유사하군”, **“모든 경우의 수... 완전 탐색이겠네, 백트래킹 적용해보자”**와 같은 연상 작용이 이루어지도록 훈련합니다. 이를 통해 코딩 테스트장에서 초반 문제 이해 및 접근법 결정 시간을 단축시키고, 안정적으로 문제 해결을 시작할 수 있을 것입니다.
